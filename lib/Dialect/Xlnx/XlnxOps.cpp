//===- XlnxOps.cpp - Xlnx dialect ops --------------------------*- C++ -*-===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//

// clang-format off
#include "circt/Dialect/Xlnx/XlnxOps.h"
#include "circt/Dialect/Xlnx/XlnxDialect.h"

#include "mlir/IR/OpAsmSupport.h"
#include "mlir/IR/Builders.h"
#include "mlir/IR/OpImplementation.h"
#include "mlir/Support/LLVM.h"
#include <cassert>
// clang-format on

using namespace mlir;
using namespace circt;
using namespace circt::xlnx;

//===----------------------------------------------------------------------===//
// XlnxLutNOp
//===----------------------------------------------------------------------===//

template <typename LutOpTy>
struct LutVerify : public LutOpTy {
  static LogicalResult commonVerify(uint32_t numInputs, uint64_t initValue,
                                    LutOpTy *op) {
    if (numInputs < 1 || numInputs > 6) {
      assert(op && "op is null");
      return op->emitError() << "requires between 1 and 6 inputs, but got "
                             << numInputs << " inputs";
    }
    static constexpr uint64_t maxValues[] = {
        (1UL << (1UL << 1)) - 1, // 1 input
        (1UL << (1UL << 2)) - 1, // 2 inputs
        (1UL << (1UL << 3)) - 1, // 3 inputs
        (1UL << (1UL << 4)) - 1, // 4 inputs
        (1UL << (1UL << 5)) - 1, // 5 inputs
        0ULL - 1, // 6 inputs, to avoid overflow, it is undefined behavior
    };
    if (initValue > maxValues[numInputs - 1]) {
      assert(op && "op is null");
      return op->emitError()
             << "INIT attribute value is too large (" << initValue
             << ") for the number of inputs (" << numInputs << ")";
    }
    return success();
  }
};

LogicalResult XlnxLutNOp::verify() {
  return LutVerify<XlnxLutNOp>::commonVerify(getInputs().size(), getINIT(),
                                             this);
}

LogicalResult XlnxLut1Op::verify() {
  return LutVerify<XlnxLut1Op>::commonVerify(1, getINIT(), this);
}

LogicalResult XlnxLut2Op::verify() {
  return LutVerify<XlnxLut2Op>::commonVerify(2, getINIT(), this);
}

LogicalResult XlnxLut3Op::verify() {
  return LutVerify<XlnxLut3Op>::commonVerify(3, getINIT(), this);
}

LogicalResult XlnxLut4Op::verify() {
  return LutVerify<XlnxLut4Op>::commonVerify(4, getINIT(), this);
}

LogicalResult XlnxLut5Op::verify() {
  return LutVerify<XlnxLut5Op>::commonVerify(5, getINIT(), this);
}

LogicalResult XlnxLut6Op::verify() {
  return LutVerify<XlnxLut6Op>::commonVerify(6, getINIT(), this);
}

//===----------------------------------------------------------------------===//
// XlnxMux*Op
//===----------------------------------------------------------------------===//

LogicalResult XlnxMuxF7Op::verify() { return success(); }

LogicalResult XlnxMuxF8Op::verify() { return success(); }

LogicalResult XlnxMuxF9Op::verify() { return success(); }

//===----------------------------------------------------------------------===//
// Xlnx FlipFlop Operations
//===----------------------------------------------------------------------===//

LogicalResult XlnxFDCEOp::verify() { return success(); }

LogicalResult XlnxFDPEOp::verify() { return success(); }

LogicalResult XlnxFDSEOp::verify() { return success(); }

LogicalResult XlnxFDREOp::verify() { return success(); }

//===----------------------------------------------------------------------===//
// TableGen generated logic.
//===----------------------------------------------------------------------===//

#include "circt/Dialect/Xlnx/XlnxOpInterfaces.cpp.inc"

// Provide the autogenerated implementation guts for the Op classes.
#define GET_OP_CLASSES
#include "circt/Dialect/Xlnx/Xlnx.cpp.inc"